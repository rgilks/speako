#!/usr/bin/env npx tsx
/**
 * Generate a markdown benchmark report from validation results.
 * 
 * Usage: npm run validate:report
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';

const INPUT_FILE = './validation-results.json';
const OUTPUT_FILE = './BENCHMARK.md';

interface ValidationResult {
  fileId: string;
  reference: string;
  hypothesis: string;
  wer: number;
  wordCount: number;
  cefrLevel: string;
  audioQuality: string;
  processingTimeMs: number;
}

interface ValidationSummary {
  timestamp: string;
  totalFiles: number;
  processedFiles: number;
  averageWER: number;
  werByLevel: Record<string, { count: number; totalWER: number; avgWER: number }>;
  totalProcessingTimeMs: number;
  results: ValidationResult[];
}

function generateReport() {
  if (!existsSync(INPUT_FILE)) {
    console.error(`‚ùå No validation results found. Run: npm run validate`);
    process.exit(1);
  }

  const data: ValidationSummary = JSON.parse(readFileSync(INPUT_FILE, 'utf-8'));
  
  // Find worst performing words (aggregate)
  const wordErrors: Map<string, { ref: string; hyp: string; count: number }> = new Map();
  for (const result of data.results) {
    if (result.wer > 0.3) {
      const key = result.reference.substring(0, 50);
      wordErrors.set(key, {
        ref: result.reference,
        hyp: result.hypothesis,
        count: (wordErrors.get(key)?.count || 0) + 1
      });
    }
  }

  // Generate WER distribution histogram
  const histogram = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 0-10%, 10-20%, etc
  for (const result of data.results) {
    const bucket = Math.min(9, Math.floor(result.wer * 10));
    histogram[bucket]++;
  }

  // Build markdown
  let md = `# Speako Benchmark Report

Generated: ${new Date(data.timestamp).toLocaleString()}

## Summary

| Metric | Value |
|--------|-------|
| Files Processed | ${data.processedFiles} / ${data.totalFiles} |
| **Average WER** | **${(data.averageWER * 100).toFixed(2)}%** |
| Total Processing Time | ${(data.totalProcessingTimeMs / 1000).toFixed(1)}s |
| Avg Time per File | ${(data.totalProcessingTimeMs / data.processedFiles).toFixed(0)}ms |

## WER by CEFR Level

| Level | Count | Avg WER |
|-------|-------|---------|
`;

  const levels = Object.entries(data.werByLevel).sort(([a], [b]) => a.localeCompare(b));
  for (const [level, stats] of levels) {
    const bar = '‚ñà'.repeat(Math.round(stats.avgWER * 20));
    md += `| ${level} | ${stats.count} | ${(stats.avgWER * 100).toFixed(2)}% ${bar} |\n`;
  }

  md += `
## WER Distribution

\`\`\`
`;
  const maxHist = Math.max(...histogram, 1);
  for (let i = 0; i < 10; i++) {
    const pct = `${i * 10}-${i * 10 + 10}%`.padStart(8);
    const bar = '‚ñà'.repeat(Math.round((histogram[i] / maxHist) * 40));
    const count = histogram[i].toString().padStart(4);
    md += `${pct} ${bar} (${count})\n`;
  }
  md += `\`\`\`

## High Error Samples

Files with WER > 30%:

| File ID | WER | Reference (first 60 chars) |
|---------|-----|---------------------------|
`;

  const highError = data.results
    .filter(r => r.wer > 0.3)
    .sort((a, b) => b.wer - a.wer)
    .slice(0, 10);

  for (const result of highError) {
    const ref = result.reference.substring(0, 60).replace(/\|/g, '\\|');
    md += `| ${result.fileId} | ${(result.wer * 100).toFixed(1)}% | ${ref}... |\n`;
  }

  md += `
---

*Report generated by \`npm run validate:report\`*
`;

  writeFileSync(OUTPUT_FILE, md);
  console.log(`üìä Report written to ${OUTPUT_FILE}`);
}

generateReport();
